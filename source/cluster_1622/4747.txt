keyword: Kiến trúc von Neumann
url: http://www.dientuvietnam.net/forums/forum/vi-%C4%91i%E1%BB%81u-khi%E1%BB%83n-mcu-b%E1%BB%99-%C4%91i%E1%BB%81u-khi%E1%BB%83n-t%C3%ADn-hi%E1%BB%87u-s%E1%BB%91-dsc/c%C3%A1c-h%E1%BB%8D-kh%C3%A1c/18039-ki%E1%BA%BFn-tr%C3%BAc-von-neumann
content:
Nếu đây là lần đầu tiên đến với Điện Tử Việt Nam, bạn có thể đọc phần Hỏi đáp bằng cách nhấn vào liên kết. Có thể bạn cần đăng kí trước khi có thể gửi bài . Để bắt đầu xem bài viết, chọn diễn đàn bạn muốn thăm dưới đây. Do dòng ARM 7 dùng kiến trúc Von Neumann, nên tôi muốn xem qua về kiến trúc này , wiki tiếng việt ko có nên tôi viết ở đây, mục đích là để nhưng bác nào quan tâm thì mình cùng trao đổi. Một điểm đáng chú ý nhất trong kiến trúc Von Neumann là khái niệm "Chương trình được lưu trữ" (stored-program). Khái niệm này chỉ ra rằng: Dữ liệu (data) cùng với lệnh (instruction) được dùng để xử lí dữ liệu đó có thể được lưu giữ trên cùng một vùng nhớ của máy tính. Ý tưởng này ngược với cấu trúc của các máy tính trước đó như máy ENIAC. Do dữ liệu và các lệnh được lưu trong cùng một vùng nhớ (vùng nhớ ở đây là RAM), nên cần thiết phải phân biệt chúng. Do giá trị trên vùng nhớ chỉ là các số nhị phân 0,1 , do đó máy tính cần phải xác định được phần nào là dữ liệu, phần nào là lệnh, khối điều khiển Von Neumann - Von Neumann Control Unit (khối số 3 ở trên ) sẽ thực hiện nhiệm vụ này. Khi khối điều khiển Von Neumann bắt đầu gọi một lệnh để xử lí, nó gọi tới bộ đếm chương trình (program counter) để trỏ tới địa chỉ của lệnh trong bộ nhớ, rồi thì lệnh này sẽ được nạp và thực thi bởi vi xử lí. Địa chỉ của dữ liệu cần xử lí được chứa trong chính lệnh cần thực thi. Đang lúc tìm nạp và thực thị lệnh, bộ đếm chương trình sẽ tăng lên để trỏ tới lệnh tiếp theo cần thực thi. Quá trình này là tuần tự, nghĩa là các lệnh được thực thi một cách tuần tự, tại mỗi thời điểm chỉ có một lệnh được thực thi (nguyên văn: one instruction at a time). Đây là đặc điểm tiêu biểu của kiến trúc Von Neumann. Để ý: khi máy tính (ở đây là CPU) tìm nạp lệnh từ bộ nhớ (fetching an instruction) hay xử lí dữ liệu trên bộ nhớ (tức thực thi lệnh) thì cũng điều xem là one instruction. Điều này có nghĩa là: Khi CPU tìm nạp lệnh từ bộ nhớ (read memory) thì nó ko thể xử lí dữ liệu (read/write memory), ngược lại, khi xử lí dữ liệu trên bộ nhớ thì nó ko thể tìm nạp lệnh. Hai thao tác trên ko thể nào thực hiện đồng thời .??? mấy bác cho ý kiến chỗ này nhé. Máy tính là sự kết hợp các các thành phần: ALU, khối điều khiển Von Neumann control unit, input/output, và một bộ nhớ có thể chứa cả lệnh và dữ liệu. Các lệnh được thực hiện một cách tuần tự, mỗi thời điểm chỉ thực hiện được một lệnh. Ngày nay, có nhiều kỹ thuật nhằm giúp hạn chế tình trạng Thắt cổ chai von Neumann , như tăng độ rộng bus dữ liệu, kỹ thuật dùng bộ nhớ cache, .cùng các kỹ thuật tiên tiến khác, tuy nhiên, bất chấp những cải tiến trên, kiến trúc dựa trên kiến trúc von Neumann vẫn là kiến trúc máy tính phổ biến nhất hiện nay. Do dòng ARM 7 dùng kiến trúc Von Neumann, nên tôi muốn xem qua về kiến trúc này khác, wiki tiếng việt ko có nên tôi viết ở đây, mục đích là để nhưng bác nào quan tâm thì mình cùng trao đổi. Bài viết của anh rất tốt, nhưng em xin cải chính gốc gác của Von Neuman. Riêng cái tên "Phôn Noi - Man" đã "tố cáo" gốc Đức của János Von Neuman, người Do Thái rất "kỵ" cái tên như thế. Ông ta viết chủ yếu bằng hai ngôn ngữ Đức và Pháp. Không sao đâu anh, Lan Hương cải chính cho vui vì em ấy học văn hoá Đức, và cũng vì ngưỡng mộ cái ông "Phôn Noi-man vĩ đại" đó thôi. Thích nhất là một luận đề toán học của ông ta chứng minh rằng sẽ có những thế hệ máy tính tự tiến hành sản xuất được những thế hệ máy tính cao hơn nó. Luận chứng này rất kinh khủng, hình như nó báo hiệu một thời đại máy tính siêu thông minh, tự phát triển độc lập ngoài ý thức con người. Một nội hàm toán học nào đó của ông ta dường như để chứng minh rằng con người cũng là một loại máy tính siêu việt. Kiến trúc Von Neumann có một bộ nhớ và một bus để chuyển dữ liệu vào và ra đơn vị xử lý trung tâm (CPU) .CPU có thể đọc một lệnh, hoặc đọc/ghi dữ liệu từ bộ nhớ. Tuy vậy, cả hai quá trình tương tác với lệnh hoặc với dữ liệu, không thể thực hiện cùng lúc.Bộ lọc Von Neumann là thỏa đáng khi chúng ta quan tâm đến việc thực hiện các nhiệm vụ tuần tự.Hầu hết các máy tính ngày nay đều sử dụng thiết kế Von Neumann.Chúng ta chỉ cần kiến trúc khác khi đòi hỏi xử lý rất nhanh, và có thể chi trả với giá cao. Aiken đã tách các bộ nhớ dữ liệu và bộ nhớ chương trình với các bus riêng rẽ cho từng bộ nhớ. Bởi vì các bus điều hành độc lập, các chỉ dẫn chương trình và dữ liệu có thể được đưa ra cùng một lúc, cải thiện tốc độ so với thiết kế với chỉ một bus. Hầu hết các bộ xử lý DSP hiện nay sử dụng kiến trúc 2 bus này. Kiến trúc SHARC, viết tắt của cụm từ Super Harvard Architecture. Thuật ngữ này được tạo ra bởi Analog Devices để diễn tả quá trình hoạt động bên trong của dòng ADSP-2106x và ADSP-211x. Ý tưởng của kiến trúc này là xây dựng dựa trên kiến trúc Harvard bằng cách thêm vào những điểm đặc trưng để cải thiện thông lượng dữ liệu. Trong khi một bộ DSP SHARC có thể được mô tả dưới nhiều cách, có 2 phần cơ bản được thêm vào là bộ nhớ đệm chỉ lệnh và điều khiển vào/ra. Phần thanh ghi dữ liệu của CPU đươc sử dụng giống như các bộ vi xử lý truyền thống. Ở các bộ xử lý ADSP-2106x SHARC, có 16 thanh ghi thông thường của mỗi 40 bit. Nó có thể nắm giữ các phép tính trung gian. chuẩn bị dữ liệu cho bộ xử lý toán học. phục vụ như buffer cho việc truyền dữ liệu, nắm các cờ cho điều khiển chương trình.Nếu cần thiết, các thanh ghi này có thể được sử dụng để điều khiển vòng lặp và bộ đếm. Tuy nhiên, bộ xử lý SHARC có các thanh ghi cứng hỗ trợ các chức năng trên. Multiplier lấy các giá trị từ 2 thanh ghi, nhân chúng lại và đưa kết quả vào một thanh ghi khác. Xử lý cơ bản đối với số nhị phân được thực hiện bởi barred shifter, như dịch chuyển hay xoay, đưa vào hay ra các phân đoạn ( segment) . Một tính năng mạnh mẽ của dòng SHARC là multiplier và ALU có thể được định chỉ song song. Ở các chu kỳ 1 xung nhịp, dữ liệu từ thanh ghi 0-7 có thể được đưa và multiplier, dữ liệu từ thanh ghi 8-15 có thể được đưa vào ALU. và 2 kết quả có thể đưa vào bất kì thanh ghi nào trong 16 thanh ghi. Bạn hãy chuyển mạch về sơ đồ tương đương AC để tính tổng trở, sau đó dùng công thức tần số cắt f=1/(2*pi*R*C) để tính C1 và C2. Dạ hông sao đâu ạ. 5v là mức logic tương đối an toàn cho chân tín hiệu ạ. Chú muốn cẩn thận hơn thì nối tiếp thêm cho nó con trở trăm ôm ấy. Con chip tên gì, bản vẽ ra sao . Có hàng chục loại chip kết nối mạng LAN trên thị trường. Chỉ nói chung chung thiết kế khối LAN với Vbus thì diễn đàn dẫu muốn giúp cũng biết đoán thế nào ?. Dạ quạt của chú nó bị chập con triac đóng cắt mô tơ swing rùi ạ chú kiếm con khác thay là xong ạ. Ngày trước chị hàng xóm nhà cháu cũg hay nghịch cái này lắm ạ giờ chị ấy lớn đi làm công nhân ở sài gòn mãi chẳng thấy về. Nhân tiện đây cho em hỏi . sao cái tuốc năng quạt treo tường Senko nhà em nó cứ quay không ngưng cho dù không bật chế độ quay (swing) thậm trí cả khi em (off)tắt quạt (vẫn cắm điện)em đã thử thay cái khác vào vẫn bị vậy. Chọn tụ sao cho tín hiệu sau khi qua 1 tụ thì giảm còn 0,86 biên độ ban đầu. Có bác nào biết pin trong kính hàn là loại nào không ạ. Để lâu không sử dụng nó không hoạt động. Đo pin được 2V. Phơi nắng cho nạp bằng nlmt thì lên được 2,7V. Hoạt động được nhưng hơi chập chờn. Qua đây mình đã bổ sung thêm một ít kiến thức nữa. Đã có cái nhìn tổng quát hơn về cái này!
