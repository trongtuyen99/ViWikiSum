keyword: Hàm băm
url: https://cryptoviet.com/hash-la-gi
content:
Về cơ bản hashing là quá trình biến một dữ liệu đầu vào có độ dài bất kỳ thành một chuỗi đầu ra đặc trưng có độ dài cố định. Một cách tổng quát hàm băm là bất kỳ hàm nào có thể được sử dụng để ánh xạ dữ liệu có kích thước tùy ý thành các giá trị kích thước cố định. Các giá trị được trả về bởi hàm băm được gọi là giá trị băm, mã băm, thông điệp băm, hoặc đơn giản là “hash”. Ví dụ, khi bạn download một video trên YouTube có dung lượng 50 MB và thực hiện hashing trên nó bằng thuật toán băm SHA-256, thì đầu ra bạn thu được sẽ là một giá trị băm có độ dài 256 bit. Tương tự, nếu bạn lấy một tin nhắn văn bản có dung lượng 5 KB, để hashing bằng SHA-256 thì giá trị băm đầu ra bạn thu được vẫn sẽ là 256 bit. Như bạn có thể thấy, trong trường hợp SHA-256, cho dù đầu vào của bạn lớn hay nhỏ như thế nào đi chăng nữa, thì đầu ra bạn nhận được sẽ luôn có độ dài 256 bit cố định. Điều này trở nên quan trọng khi bạn xử lý một lượng lớn dữ liệu và giao dịch. Khi đó, thay vì bạn phải xử lý toàn bộ lượng dữ liệu đầu vào (có thể có kích thước rất lớn), bạn chỉ cần xử lý và theo dõi một lượng dữ liệu rất nhỏ là các giá trị băm. Trong blockchain, các giao dịch có độ dài khác nhau sẽ được băm thông qua một thuật toán băm nhất định và tất cả đều cho đầu ra có độ dài cố định bất kể độ dài của giao dịch đầu vào là bao nhiêu. Chẳng hạn, Bitcoin sử dụng thuật toán SHA-256 để băm các giao dịch cho kết quả đầu ra có độ dài cố định là 256 bit (32 byte) cho dù giao dịch chỉ là một từ hoặc giao dịch phức tạp với lượng dữ liệu khổng lồ. Điều làm cho việc theo dõi các giao dịch trở nên dễ dàng hơn khi truy xuất và theo dõi lại các giá trị băm. Kích thước của hàm băm sẽ phụ thuộc vào hàm băm được sử dụng. Kỹ thuật hashing thường được sử dụng và có ứng dụng rộng rãi nhất trong việc đảm bảo tính toàn vẹn cho dữ liệu trong blockchain là các hàm băm mật mã (cryptographic hash function) chẳng hạn như SHA-1. SHA-3, SHA-256…Sỡ dĩ như vậy là do các hàm băm mật mã có một số tính chất quan trọng phù hợp cho việc đảm bảo an toàn dữ liệu. Hàm băm mật mã là các hàm băm phù hợp để sử dụng trong mật mã. Cũng giống như các hàm băm thông thường, nó là một thuật toán toán học ánh xạ dữ liệu có kích thước tùy ý thành một chuỗi bit có kích thước cố định (gọi là “giá trị băm”, “mã băm” hoặc “thông điệp băm”). Ngoài ra nó còn đảm bảo tính chất là một hàm một chiều, nghĩa là, một hàm mà trên thực tế không thể có ngược. Nếu bạn có một giá trị băm đầu ra, bạn sẽ không thể suy ngược lại được giá trị đầu vào là gì để có thể băm ra một thông điệp băm như vậy, hoặc ít nhất là rất khó suy luận được ra, trừ khi bạn vét cạn hết toàn bộ các khả năng có thể của thông điệp đầu vào. Đây là tính chất vô cùng quan trọng của hàm băm mật mã biến nó thành một công cụ cơ bản của mật mã hiện đại. Các hàm băm mật mã có nhiều ứng dụng trong an toàn thông tin. Nó được sử dụng nhiều trong chữ ký số, mã xác thực thông điệp (MAC) và các hình thức xác thực khác. Ngoài ra, chúng cũng có thể được sử dụng như các hàm băm thông thường, để lập chỉ mục dữ liệu trong bảng băm, lấy đặc trưng của dữ liệu, phát hiện dữ liệu trùng lặp hoặc làm tổng kiểm tra để phát hiện lỗi các dữ liệu ngẫu nhiên. Tính tất định, nghĩa là cùng một thông điệp đầu vào luôn tạo ra cùng một hàm băm. Có khả năng tính toán nhanh chóng giá trị băm của bất kỳ thông điệp nào. Đảm bảo rằng bất kỳ một thay đổi nào, dù là nhỏ nhất trên dữ liệu đều sẽ gây ra sự thay đổi cực lớn trên giá trị băm và tạo ra giá trị băm hoàn toàn khác, và không hề có liên hệ gì với giá trị băm cũ (hiệu ứng tuyết lở). Như bạn thấy, mặc dù bạn chỉ thay đổi duy nhất một chữ cái đầu tiên của đầu vào thì đầu ra đã gần như thay đổi hoàn toàn. Đây là một tính chất quan trọng của hàm băm bởi vì nó dẫn đến một trong những tính chất lớn nhất của blockchain, đó là tính bất biến. Nghĩa là bạn không thể tạo ra một thay đổi nào trên blockchain mà không tạo ra một sự thay đổi lớn trên đầu ra. Bạn không thể sửa 10 thàng 100 trong giao dịch và ngược lại…. Ngoài ra, với mục đích đảm bảo an toàn cho dữ liệu, các hàm băm mật mã phải có khả năng chịu được tất cả các loại tấn công mã hóa đã biết. Trong lý thuyết mật mã, mức độ an toàn của hàm băm mật mã đã được xác định bằng các thuộc tính sau:. Tính kháng tiền ảnh thứ nhất. Tính chất yêu cầu rằng với một giá trị băm h bất kỳ, sẽ khó tìm thấy bất kỳ thông điệp m nào sao cho h = hash (m). Khái niệm này có liên quan đến tính chất một chiều của hàm băm. Tính kháng va chạm. Một giá trị như vậy được gọi là va chạm của hàm băm mật mã. Ký hiệu D là miền xác định và R là miền giá trị của hàm băm h(x). Do hàm băm biến đổi dữ liệu từ độ dài bất kỳ về độ dài cố định do đó, số lượng phần tử của D thường lớn hơn rất nhiều so với số lượng phần tử trong R. Vì vậy hàm băm h(x) không là đơn ánh, tức là luôn tồn tại một cặp đầu vào khác nhau có cùng giá trị mã băm. Tức là với mỗi đầu vào cho trước thường tồn tại một (hoặc nhiều) đầu vào khác sao cho mã băm của nó trùng với mã băm của chuỗi đầu vào đã cho. Tính chất này dựa trên ngịch lý ngày sinh nhật:. Nếu bạn gặp bất kỳ người lạ ngẫu nhiên nào trên đường phố, khả năng cả hai bạn có cùng ngày sinh là rất thấp. Trên thực tế, giả sử rằng tất cả các ngày trong năm đều có khả năng sinh nhật như nhau, khả năng có một người khác cùng có ngày sinh như bạn là 1/365 tức là chỉ xấp xỉ 0,27%. Tuy nhiên, nếu bạn tập hợp 20-30 người trong một phòng, tỷ lệ hai người có cùng một ngày sinh nhật tăng lên gấp bội. Trên thực tế, có cơ hội để 2 người bất kỳ chia sẻ cùng một ngày sinh nhật trong trường hợp này là 50-50 !. Tại sao điều này xảy ra? Đó là bởi vì một quy tắc đơn giản trong xác suất. Giả sử bạn có N khả năng khác nhau xảy ra, thì bạn cần căn bậc hai của N đối tượng ngẫu nhiên để chúng có 50% khả năng xảy ra va chạm. Vì vậy, áp dụng lý thuyết này cho ngày sinh nhật, bạn có 365 khả năng ngày sinh nhật khác nhau, vì vậy bạn chỉ cần √365, tức là ~ 23 người, những người được chọn ngẫu nhiên thì 50% cơ hội hai người sẽ có chung ngày sinh nhật. Với trường hợp hashing ở đây, giả sử bạn có hàm băm với kích thước đầu ra là 128 bit, tức là có tổng thể 2 ^ khả năng khác nhau. thì với nghịch lý sinh nhật, bạn có 50% cơ hội phá vỡ khả năng kháng va chạm của hàm băm với √(2^128) = 2^64 lần thử. Do đó, bạn có thể thấy rằng, việc phá vỡ tính chất kháng va chạm của hàm băm sẽ dễ dàng hơn rất nhiều so với việc phá vỡ tính chất kháng tiền ảnh. Không có hàm băm nào là không va chạm, tuy nhiên, nếu ta chọn được hàm h(x) thích hợp đáp ứng tính chất trên với chiều dài mã băm đủ lớn thì việc tính toán để tìm ra chuỗi đầu vào bị va chạm này là rất khó . Tính kháng va chạm bao hàm cả tính kháng tiền ảnh thứ hai, nhưng không bao gồm tính chất kháng tiền ảnh thứ nhất. Trên thực tế, hàm băm chỉ có khả năng kháng tiền ảnh thứ hai được coi là không an toàn và do đó không được khuyến nghị cho các ứng dụng thực tế. Các tính chất trên đảm bảo rằng kẻ tấn công không thể thay thế hoặc sửa đổi dữ liệu đầu vào mà không làm thay đổi giá trị băm. Do đó, nếu hai chuỗi đầu vào có cùng một giá trị băm, ta có thể rất tự tin rằng chúng là giống hệt nhau. Tính kháng tiền ảnh thứ hai ngăn chặn kẻ tấn công tạo ra được một tài liệu khác có cùng giá trị băm như tài liệu gốc. Tính kháng va chạm ngăn chặn kẻ tấn công tạo ra hai tài liệu khác nhau mà có cùng một giá trị băm. Các thuật toán tính tổng kiểm tra, chẳng hạn như CRC32 và các thuật toán tính mã kiểm tra dự phòng theo chu kỳ khác, được thiết kế để đáp ứng các yêu cầu yếu hơn nhiều và thường không phù hợp với các ứng dụng như các hàm băm mật mã. Ví dụ: CRC được sử dụng xác minh tính toàn vẹn của thông điệp trong tiêu chuẩn mã hóa WEP, nhưng có thể bị dễ dàng tấn công bằng các tấn công có độ phức tạp tuyến tính. Có nhiều thuật toán băm mật mã; ở đây chúng ta nhắc đến một số thuật toán được sử dụng thường xuyên. MD5 được Ronald Rivest thiết kế vào năm 1991 để thay thế hàm băm MD4 trước đó và được đưa thành tiêu chuẩn vào năm 1992 trong RFC 1321. MD5 tạo ra một bản tóm tắt có kích thước 128 bit (16 byte). Tuy nhiên, đến đầu những năm 2000 thì hàm băm MD5 trở lên không an toàn trước sức mạnh tính toán của các hệ thống tính toán thế hệ mới. Với sức mạnh tính toàn và sự phát triển của công nghệ thám mã thời gian gần đây, chúng ta có thể tính toán các va chạm trong MD5 với độ phức tạp 221 phép toán chỉ trong vòng vài giây khiến thuật toán không phù hợp với hầu hết các trường hợp sử dụng trong thực tế. SHA-1 được phát triển như một phần của dự án Capstone của Chính phủ Hoa Kỳ. Nó đã bị NSA rút lại ngay sau khi xuất bản và được thay thế bởi phiên bản sửa đổi, được xuất bản năm 1995 trong FIPS PUB 180-1 và thường được đặt tên là SHA-1. SHA-1 tạo ra bản tóm tắt có kích thước 160 bit (20 byte). Các va chạm chống lại thuật toán SHA-1 đầy đủ có thể được tạo ra bằng cách sử dụng tấn công phá vỡ. Do đó, hàm băm này cho đến nay được coi là không đủ an toàn. RIPEMD (viết tắt của RACE Integrity Primitives Evaluation Message Digest) là họ hàm băm được phát triển tại Leuven, Bỉ, bởi ba nhà mật mã học Hans Dobbertin, Antoon Bosselaers và Bart Preneel của nhóm nghiên cứu COSIC thuộc đại học Katholieke Universiteit Leuven. RIPEMD lần đầu tiên được công bố vào năm 1996 dựa trên các nguyên tắc thiết kế được sử dụng trong MD4. RIPEMD-160 tạo ra một bản tóm tắt gồm 160 bit (20 byte). RIPEMD có hiệu năng tương tự như SHA-1 nhưng ít được phổ biến hơn. Và cho đến nay RIPEMD-160 chưa bị phá vỡ. bcrypt là một hàm băm mật khẩu được thiết kế bởi Niels Provos và David Mazières, dựa trên mật mã Blowfish, và được trình bày tại USENIX vào năm 1999. Bên cạnh việc kết hợp một giá trị ngẫu nghiên salt để bảo vệ chống lại các tấn công rainbow attack, bcrypt còn là một hàm có khả năng thích ứng: theo thời gian, số lần lặp có thể được tăng lên để làm cho nó chậm hơn, do đó nó vẫn có khả năng chống lại các cuộc tấn công vét cạn ngay cả khi tăng sức mạnh tính toán có lớn đến mức nào đi chăng nữa. Whirlpool là một hàm băm mật mã được thiết kế bởi Vincent Rijmen và Paulo S. L. M. Barreto. Nó được mô tả đầu tiên vào năm 2000. Whirlpool dựa trên phiên bản sửa đổi đáng kể của Tiêu chuẩn mã hóa nâng cao (AES). Whirlpool tạo ra một bản tóm tắt có độ dài 512 bit (64 byte) của dữ liệu. SHA-2 là một tập hợp các hàm băm mật mã được thiết kế bởi Cơ quan an ninh quốc gia Hoa Kỳ (NSA), được xuất bản lần đầu tiên vào năm 2001. Chúng được xây dựng bằng cấu trúc Merkle–Damgård, chức năng nén một chiều của nó được xây dựng bằng cấu trúc Davies–Meyer từ một hệ mật mã khối chuyên dụng. SHA-2 về thực chất bao gồm hai thuật toán băm: SHA-256 và SHA-512. SHA-224 là một biến thể của SHA-256 với các giá trị khởi tạo và đầu ra bị cắt bỏ khác nhau. SHA-384 và SHA-512/224 và SHA-512/256 ít được biết đến là tất cả các biến thể của SHA-512. Do có nhiều phiên bản thuật toán khác nhau do đó kích thước đầu ra của họ SHA-2 cũng khác nhau tùy theo thuật toán. Phần mở rộng của tên phía sau tiền tố “SHA” chính là độ dài của thông điệp băm đầu ra. Ví dụ với SHA-224 thì kích thước đầu ra là 224 bit (28 byte), SHA-256 tạo ra 32 byte, SHA-384 tạo ra 48 byte và cuối cùng là SHA- 512 tạo ra 64 byte. Và chúng ta có thể đã biết rằng Bitcoin sử dụng hàm băm SHA-256 là một phiên bản trong họ SHA-2 này. SHA-3 được NIST phát hành vào ngày 5 tháng 8 năm 2015. Đây có lẽ là tiêu chuẩn hàm băm mới nhất cho đến hiện nay. SHA-3 là một tập con của họ nguyên thủy mật mã rộng hơn là Keccak. Cấu trúc này cũng có thể được sử dụng để xây dựng các nguyên thủy mã hóa khác như các hệ mật mã dòng. SHA-3 cũng có các kích cỡ đầu ra tương tự như SHA-2 bao gồm: 224, 256, 384 và 512 bit. Một phiên bản cải tiến của BLAKE có tên BLAKE2 đã được công bố vào ngày 21 tháng 12 năm 2012. Mặc dù BLAKE và BLAKE2 chưa được tiêu chuẩn hóa như SHA-3, nhưng nó đã được sử dụng trong nhiều giao thức bao gồm hàm băm mật khẩu Argon2 do hiệu quả cao mà nó mang lại cho các dòng CPU hiện đại. Do BLAKE cũng là ứng cử viên cho tiêu chuẩn SHA-3, vì vậy, BLAKE và BLAKE2 đều có các kích thước đầu ra giống như SHA-3 và có thể tùy chọn khi sử dụng trong thực tế. Hashing nói chung và hàm băm mật mã nói riêng có rất nhiều ứng dụng khác nhau trong thực tế. Dưới đây là một số ứng dụng phổ biến nhất của nó:. Giá trị băm cũng có thể được sử dụng như một phương tiện để định danh tập tin một cách đáng tin cậy. Một số hệ thống quản lý mã nguồn, như Git, Mercurial hay Monotone, sử dụng giá trị sha1sum của nội dung tệp, cây thư mục, thông tin thư mục gốc, v.v. để định danh chúng.
