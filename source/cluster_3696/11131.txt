keyword: Con trỏ rỗng
url: https://cafedev.vn/tu-hoc-c-tim-hieu-ve-con-tro-nullnull-pointers-trong-c/
content:
Giống như các biến thông thường, con trỏ cũng không được khởi tạo khi chúng được thể hiện/khai báo (instantiated). Trừ khi có một giá trị được gán, nếu không thì con trỏ sẽ trỏ đến một số địa chỉ rác theo mặc định. Ngoài địa chỉ bộ nhớ ra, còn có một giá trị khác mà con trỏ có thể giữ: đó là giá trị null. Giá trị null là một giá trị đặc biệt, có ý nghĩa là con trỏ đang không trỏ đến bất cứ thứ gì. Một con trỏ chứa giá trị null được gọi là con trỏ null. Trong C++, chúng ta có thể gán giá trị null cho một con trỏ bằng cách khởi tạo hoặc gán cho nó giá trị bằng 0. Do đó, chúng ta có thể sử dụng một câu lệnh kiểm tra điều kiện để kiểm tra liệu rằng một con trỏ có null hay không:. Thực hành tốt: Hãy khởi tạo con trỏ với một giá trị null nếu bạn đang không gán giá trị nào cho chúng. Trong bài trước, chúng ta đã biết rằng việc dereferencing một con trỏ rác sẽ dẫn đến các kết quả không xác định. Việc dereferencing một con trỏ null cũng sẽ dẫn đến lỗi hành vi không xác định (undefined behavior). Trong hầu hết các trường hợp, nó sẽ làm ứng dụng của bạn bị crash. Về mặt khái niệm, điều này thật sự có ý nghĩa. Việc dereferencing một con trỏ có nghĩa là “đi đến địa chỉ mà con trỏ đang trỏ tới và truy cập vào giá trị ở đó”. Và một con trỏ null thì giữ địa chỉ nào bên trong nó. Vì thế, hãy thử nghĩ xem, khi bạn cố gắng truy cập giá trị tại địa chỉ đó, con trỏ nên làm thế nào đây?. Giải thích macro là gì: Một macro là một đoạn code đã được đặt tên. Bất cứ khi nào tên này được sử dụng, nó sẽ được thay thế bằng nội dụng của macro. Có hai loại macro. Chúng khác nhau chủ yếu ở về hình thức khi chúng được sử dụng. Các macro giống như đối tượng (Object-like macros) thì giống với các đối tượng dữ liệu khi được sử dụng, các macro giống hàm (Function-like macro) thì giống với các lời gọi hàm. Quay trở lại với con trỏ, lưu ý rằng giá trị 0 không phải là một kiểu dữ liệu con trỏ, do đó việc gán 0 (hoặc NULL, trước C++ 11) cho một con trỏ để biểu thị rằng nó là con trỏ null dường như gây ra sự không nhất quán. Trong một số trường hợp hiếm, khi được sử dụng làm đối số theo nghĩa đen, nó thậm chí có thể gây ra sự cố vì trình biên dịch không thể hiểu được chúng ta đangmuốn nói đến một con trỏ null hay số nguyên 0. Trong trường hợp có khả năng NULL được định nghĩa là giá trị 0, khi thực hiện print(NULL) thực chất sẽ là gọi print(int), chứ không phải print(int*) như bạn vẫn mong đợi đối với một con trỏ null đúng nghĩa. Để giải quyết vấn đề ở bên trên, C++ 11 đã giới thiệu 1 từ khóa mới gọi là nullptr. nullptr vừa là một từ khóa, và vừa là một giá trị hằng rvalue, giống như các từ khóa boolean là true và false. C++ sẽ ngầm định chuyển đổi nullptr thành bất kỳ kiểu dữ liệu con trỏ nào. Vì vậy, trong ví dụ trên, nullptr đã được chuyển đổi ngầm định thành một con trỏ kiểu nguyên, và sau đó giá trị của nullptr được gán cho ptr. Điều này có tác dụng làm cho con trỏ kiểu nguyên ptr trở thành một con trỏ null. Thực hành tốt: Với C++ 11, hãy sử dụng từ khóa nullptr để khởi tạo con trỏ với một giá trị null. C++ 11 cũng giới thiệu một kiểu dữ liệu mới gọi là std::nullptrt (trong header <cstddef>). std::nullptrt chỉ có thể giữ một giá trị: đó là nullptr! Mặc dù điều này có vẻ hơi ngớ ngẩn, nhưng nó lại hữu dụng trong một số tình huống. Nếu chúng ta muốn viết một hàm mà chỉ nhận vào đối số nullptr, vậy chúng ta sẽ thiết đặt kiểu dữ liệu nào cho đối số của hàm?. Chúng tôi xin lỗi vì bài viết chưa được chất lượng. Chúng tôi sẽ cải thiện nó sớm nhất!. Lưu tên, email và trang web của tôi trong trình duyệt này cho lần tiếp theo tôi nhận xét.
