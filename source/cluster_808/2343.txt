keyword: Không gian tên
url: https://ichi.pro/vi/6-dieu-can-biet-de-xac-minh-khong-gian-ten-va-pham-vi-trong-python-269608997090671
content:
Khi tôi dạy viết mã Python, không gian tên và phạm vi là một trong những khái niệm phức tạp mà tôi nhận thấy làm phiền nhiều sinh viên của mình. Họ biết khái niệm này, nhưng khi tôi yêu cầu họ giải thích chính xác nó là gì, họ bị mắc kẹt ở chỗ này hay chỗ khác và không thể liên hệ khái niệm với một số cách sử dụng thích hợp. Trong bài viết này, tôi sẽ xem xét sáu điểm quan trọng, sử dụng các ví dụ có liên quan với mỗi điểm, nếu có. Ở phần cuối của hướng dẫn này, tôi hy vọng rằng bạn sẽ hiểu rõ hơn về không gian tên cũng như phạm vi - một khái niệm liên quan chặt chẽ đến không gian tên. Không gian tên được đặt tên theo cách mà không có bất kỳ sự mơ hồ nào. Tên là định danh và khoảng trắng là cấu trúc hoặc tổ chức. Chúng tôi có thể tương tự hóa các không gian tên dưới dạng bảng phân công, sử dụng tên của các cá nhân để theo dõi các thành viên. Về không gian tên, chúng tôi sử dụng tên để theo dõi các đối tượng. Bạn có thể đã nghe nói rằng mọi thứ trong Python đều là một đối tượng. Khi chúng tôi viết các chương trình Python, chúng tôi xác định các lớp và mô-đun tùy chỉnh; xây dựng danh sách, từ điển và các trường hợp tùy chỉnh khác; và tạo các chức năng. Các lớp, mô-đun, cá thể và thậm chí là các hàm này đều là các đối tượng trong Python. Giống như bảng phân công được sử dụng để theo dõi các thành viên, không gian tên là cơ chế tích hợp của Python để theo dõi các đối tượng, chẳng hạn như các đối tượng và chức năng. Như đã thảo luận ở trên, không gian tên sử dụng số nhận dạng để theo dõi các đối tượng cụ thể. Điều này nghe có vẻ quen thuộc với bạn?. Trực giác của bạn là đúng. Cơ chế ánh xạ này là những gì chúng tôi sử dụng trong một cấu trúc dữ liệu tích hợp sẵn trong Python: từ điển. Mặc dù bản thân không gian tên là một khái niệm trừu tượng, việc triển khai cụ thể của chúng sử dụng từ điển trong Python. Như được hiển thị trong đoạn mã trên, chúng tôi sử dụng globals()hàm tích hợp để hiển thị các mã nhận dạng, cùng với các đối tượng tương ứng của chúng trong không gian tên hiện tại. Bạn có thể thấy rằng từ điển này bao gồm danh sách đã xác định, hàm, lớp, các đối tượng thể hiện và các đối tượng dựng sẵn khác. Bên cạnh globals()chức năng theo dõi các đối tượng trong module như một không gian tên chung , chúng ta có thể sử dụng locals()chức năng theo dõi các đối tượng trong hàm như một không gian tên cục bộ . Như bạn có thể thấy trong lệnh foo()gọi hàm, chúng ta có thể thấy biến cục bộ bđang được theo dõi bởi không gian tên cục bộ. Lưu ý thêm, chúng ta có thể sử dụng locals()hàm để hiển thị các đối tượng được theo dõi cho không gian tên chung của mô-đun, có tác dụng tương tự khi sử dụng globals()hàm. Ngược lại, khi globals()hàm được gọi trong một hàm, nó sẽ vẫn hiển thị các đối tượng được theo dõi bởi không gian tên chung, trong trường hợp đó, đó là mô-đun. Không gian tên được sử dụng để theo dõi các đối tượng. Trong mã hóa Python của chúng tôi, chúng tôi luôn tạo các đối tượng và xóa một số đối tượng mà chúng tôi không sử dụng, nếu chúng tôi chọn làm như vậy. Nói cách khác, không gian tên là động. Hãy sử dụng một ví dụ đơn giản để minh họa tính năng động của không gian tên. Giả sử rằng chúng ta có mô-đun sau. Để rõ ràng, chúng ta sẽ sử dụng keys()hàm để chỉ hiển thị các khóa của từ điển cho không gian tên chung. Như được hiển thị trong đoạn mã bên dưới, chúng tôi có thể thêm và xóa các biến trong không gian tên chung. Bên cạnh những thay đổi trong không gian tên, động lực của không gian tên cũng có thể được phản ánh bởi thực tế rằng không gian tên có thể là tạm thời. Ví dụ, việc gọi một hàm sẽ tạo ra một vùng tên cục bộ, vùng này ánh xạ các đối tượng trong hàm và vùng tên này sẽ biến mất khi cuộc gọi hàm kết thúc. Ban đầu, chúng tôi đã nói rằng không gian tên giống như bảng phân công, vì cả hai đều được sử dụng để theo dõi các thành viên của họ. Họ chia sẻ một đặc điểm khác: ranh giới . Các thành viên trong danh sách thuộc cùng một hội đồng, ủy ban hoặc tổ chức, trong khi các đối tượng trong không gian tên có giới hạn được chỉ định. Trong nhiều hướng dẫn, phạm vi được thảo luận cùng với không gian tên. Nhưng phần lớn chúng quá kỹ thuật để người mới bắt đầu có thể hiểu được. Ở đây, tôi đang đề xuất một điều gì đó có lẽ đơn giản hơn. Như thể hiện trong hình trên, giả sử rằng chúng ta có một mô-đun với một loạt các đối tượng được xác định, bao gồm một số thuộc tính (ví dụ attr0:), các lớp tùy chỉnh (ví dụ cls0:), các hàm (ví dụ, fun0) và một số trường hợp (ví dụ obj0:). Không gian tên theo dõi tất cả các đối tượng trong mô-đun này, có thể được coi như một vùng chứa các đối tượng này. Do đó, chúng ta có thể khái niệm rằng không gian tên là không gian bên trong của vùng chứa chứa đầy các đối tượng được đặt tên khác nhau , như thể hiện trong màu xanh lá cây ở trên. Phạm vi là toàn bộ cấu trúc bao quanh của vùng chứa, xác định ranh giới của mô-đun, như được hiển thị trong màu cam ở trên. Sử dụng một giải thích kỹ thuật hơn, phạm vi là ranh giới trong đó các đối tượng cụ thể có thể truy cập bởi các đối tượng và hoạt động khác . Nói cách khác, giả sử rằng chúng ta chạy một hàm sử dụng attr0trong mô-đun trên và nếu hàm không có quyền truy cập vào phạm vi, thì nó attr0không thể được sử dụng. Hãy xem một ví dụ cụ thể. Giả sử rằng chúng ta tạo một mô-đun có tên namespacesstudentnhư được hiển thị trong đoạn mã sau. Chúng ta chỉ cần khai báo một biến boolean được đặt tên workinghardvà một lớp tùy chỉnh được đặt tên Studentvới một phương thức thể hiện được gọi study(). Khi chúng tôi làm việc với trình thông dịch của mình, nó sẽ mặc định lấy mô-đun hiện tại làm chương trình chính. (BTW, đây là lý do tại sao từ điển ở trên của không gian tên toàn cục có “main”cho namekhóa.) Lúc đầu, chúng tôi không thể truy cập workinghardbiến, vì chúng tôi đang ở bên ngoài mô-đun. Tuy nhiên, sau khi nhập nó, chúng tôi có quyền truy cập vào biến. Tuy nhiên, chúng ta phải sử dụng tên của mô-đun làm tiền tố, đây là một dấu hiệu khác về sự tồn tại của ranh giới của mô-đun. Bên cạnh đó, bằng cách nhập mô-đun này, mô-đun đã trở thành một phần của chương trình chính, như được tiết lộ bởi đầu ra từ việc gọi globals()hàm. Một hàm ý khác về ranh giới của không gian tên là khi nhiều mô-đun có các thuộc tính trùng tên, chúng ta nên đặt tiền tố các thuộc tính bằng tên mô-đun để ngăn chặn bất kỳ sự mơ hồ nào trong mã của chúng tôi. Ví dụ: nếu cả hai mô-đun được nhập avà bcó cùng thuộc tính, cụ thể là sharedattribute, chúng ta nên sử dụng a.sharedattributehoặc b.sharedattributecụ thể. Nếu không, một thuộc tính sẽ tạo bóng cho thuộc tính kia (xem bên dưới về việc tạo bóng thay đổi). Do đó, cần lưu ý rằng không gian tên là các thực thể riêng biệt, mỗi thực thể có ranh giới hoặc phạm vi riêng. Sơ đồ sau đây cho thấy đặc điểm này. Như đã thảo luận trong phần trên, không gian tên có thể có các mối quan hệ độc lập, mà chúng ta có thể khái niệm hóa như một hình chiếu ngang của các không gian tên này. Chúng sẽ trông như thế nào nếu chúng ta nhìn chúng từ góc nhìn dọc?. Khi chúng tôi ra mắt một dịch Python, một số được xây dựng trong các kiểu dữ liệu (ví dụ list, tuple) và chức năng (ví dụ print(), id()) đã có sẵn cho chúng tôi để sử dụng, vì chúng là một phần của không gian tên built-in . Khi chúng tôi tạo mô-đun, chúng tôi sẽ có không gian tên toàn cục , như được tiết lộ trong ví dụ trên, bằng cách sử dụng globals()hàm. Khi chúng tôi tạo các hàm, chúng tôi sẽ có các không gian tên cục bộ . Khi các không gian tên này được tạo, các phạm vi tương ứng của chúng cũng được tạo tự động. Một đặc điểm quan trọng của không gian tên là chúng có mối quan hệ phân cấp. Tương tự, các phạm vi có cùng một hệ thống phân cấp. Như thể hiện trong hình trên, không gian tên và phạm vi tích hợp bao gồm phạm vi và không gian tên toàn cục , bao gồm thêm phạm vi và không gian tên cục bộ . Chúng tôi đã đề cập rằng phạm vi là ranh giới xác định khả năng truy cập của các đối tượng kèm theo của chúng và phạm vi có mối quan hệ phân cấp và những phạm vi này đưa chúng ta đến cuộc thảo luận về quy tắc LEGB - quy tắc xác định thứ tự của phạm vi mà sau đó trình thông dịch Python giải quyết các tên (ví dụ: biến, hàm) cho bất kỳ hoạt động nhất định nào (ví dụ: truy cập thuộc tính, gọi hàm) . Cụ thể, LEGB là từ viết tắt của phạm vi cục bộ, bao quanh, toàn cầu và phạm vi tích hợp. Trước đây, chúng ta đã thảo luận về phạm vi cục bộ, toàn cầu và phạm vi tích hợp là gì. Nhưng phạm vi bao quanh là gì?. Gọi outerfunctionsẽ tạo ra 11, 2, và 3 cho a, bvà c. Chúng tôi lưu ý thêm rằng giá trị trả về của outerfunctionhàm là giá trị trả về của việc gọi innerfunctionhàm. Trong phạm vi cục bộ, chúng tôi có biến c, nhưng không có avà b. Vì vậy, các thông dịch viên tiếp tục tìm kiếm bằng cách một phạm vi lên, và trong phạm vi bao quanh, nó nằm avà bvà hoàn thành cuộc gọi chức năng bằng cách in cả ba biến này. Nếu nó không thể tìm thấy các biến cần thiết, trình thông dịch sẽ đi đến phạm vi toàn cục và phạm vi tích hợp sẵn. Nếu nó vẫn không thể tìm thấy các biến cần thiết, trình thông dịch sẽ tạo ra một NameErrorchỉ báo rằng các biến thích hợp không được xác định. Do đó, quy tắc LEGB xác định thứ tự tra cứu cho các tên đã cho , như thể hiện trong sơ đồ sau. Một điều cần lưu ý là nếu một biến nằm ở phạm vi thấp hơn, trình thông dịch sẽ dừng lại ở đó mà không chuyển sang mức phạm vi tiếp theo. Trong trường hợp của biến atrong ví dụ trên, giá trị in ra của việc gọi outerfunctionlà 11, là giá trị được xác định trong phạm vi bao quanh của innerfunction. Nếu chúng ta in biến atrong chương trình chính, chúng ta nhận thấy rằng giá trị là 1, là giá trị được xác định trong phạm vi toàn cục. Hiện tượng này được gọi là che tên hoặc che bóng biến đổi . Bài viết này không nhằm mục đích là một hướng dẫn đầy đủ về chủ đề này. Một số chủ đề liên quan, như từ khóa toàn cầu và từ khóa phi địa phương, có thể được khám phá trong các bài viết tiếp theo của tôi. Tuy nhiên, chúng tôi đã xem xét các khía cạnh thiết yếu liên quan đến sự hiểu biết về không gian tên và phạm vi trong Python. Không gian tên sử dụng từ điển để theo dõi các đối tượng có định danh. Không gian tên có ranh giới hoặc phạm vi xác định các vùng mà tên có thể được tra cứu. Tại sao chúng ta phải hiểu định lý thông qua phân phối xác suất thay vì chỉ xác suất điểm Định lý Bayes là một định luật quan trọng trong lý thuyết xác suất. Nó được áp dụng trong thường xuyên, cũng như thống kê Bayes. Cây quyết định là một mô hình học máy có giám sát được sử dụng cho cả nhiệm vụ phân loại và hồi quy (CART). Chúng dễ thực hiện, dễ giải thích và là một trong những công cụ học máy được sử dụng nhiều nhất. The Pragmatic Programmer được xuất bản lần đầu tiên vào năm 1999 và kể từ đó được mệnh danh là cuốn sách lập trình hay nhất mọi thời đại. Các tác giả Andy Hunt và David Thomas là một trong những tác giả ban đầu của Tuyên ngôn Agile và có một số bằng chứng xác thực. Tìm hiểu về cách những kẻ tấn công có thể đánh cắp trang web của bạn hoặc thực hiện các cuộc tấn công từ chối dịch vụ, sử dụng giao diện GraphQL có sẵn công khai của bạn. Họ có thể thực hiện điều này theo một trong bốn cách: bằng cách xây dựng cẩn thận một truy vấn lớn duy nhất để thực thi nó, bằng cách viết nhiều truy vấn song song có thể tìm nạp dữ liệu liên quan, bằng cách sử dụng các yêu cầu theo lô để đưa ra nhiều truy vấn liên tiếp và cuối cùng bằng cách gửi rất nhiều yêu cầu. Khi phỏng vấn cho một vị trí trong ngành công nghệ, bạn thường sẽ trải qua ít nhất ba vòng phỏng vấn trước khi bất kỳ lời đề nghị nào được xem xét. Các vòng thường trông giống như thế này: Nếu bạn nghĩ vậy, bạn đã nhầm. Những thứ phi kỹ thuật tạo nên những nhà phát triển tuyệt vời Tôi đã ngừng viết bài này một thời gian - tôi chưa bao giờ cảm thấy đủ điều kiện để viết nó. Hôm nay tôi nghĩ đã đến lúc viết nó. Người hâm mộ Grace and Frankie sẽ có thêm tám tập nữa để thưởng thức trước khi bộ phim có dấu hiệu khởi sắc. Họ có một số ý tưởng về những gì sẽ xảy ra. Bây giờ, nhiều năm sau khi nhiều khán giả nhảy tàu, một số bị hấp dẫn bởi sự tự phụ của loạt phim mới, The Walking Dead: World Beyond. Hoàng tử Harry và Meghan Markle có thể sẽ phá vỡ truyền thống hoàng gia với con gái Lilibet của họ khi nói đến nghi thức thông hành cụ thể này. Quán cà phê Alice Waters mở ở Berkeley, California, vào năm 1971, đã khởi xướng phong trào ẩm thực California và từ trang trại đến bàn ăn. Năm mươi năm sau Chez Panisse vẫn là một trong những nhà hàng có ảnh hưởng nhất của nước Mỹ. FDA đã hoàn toàn chấp thuận vắc-xin Pfizer COVID-19 cho những người từ 16 tuổi trở lên, nhưng điều đó vẫn khiến trẻ em dưới 12 tuổi không đủ điều kiện để tiêm chủng. Có nên xem xét việc sử dụng ngoài nhãn để bảo vệ chúng không?. Hai chuyên gia khủng bố cân nhắc về nhóm đứng sau vụ tấn công sân bay Kabul chết người và sự cạnh tranh của lực lượng này với Taliban. Tốt hơn bạn nên đo nó trước khi đeo nhẫn. Ít nhất thì đó là những gì Beyoncé đã nói, và cô ấy đã có cho mình một viên kim cương 18 carat. Come From Away Cho đến khi "vở nhạc kịch 11/9" đi, ít thành công hơn, hoặc được giới phê bình đánh giá cao như Come From Away sản xuất của Canada. Được chỉnh sửa lần đầu vào năm 2012 — và ra mắt lần đầu trên sân khấu Broadway vào năm 2017 — vở nhạc kịch từng đoạt giải Tony kể về câu chuyện của một số người trong số hàng nghìn người bị máy bay chuyển hướng đến một thị trấn nhỏ ở Newfoundland vào ngày 11 tháng 9 năm 2001 và những nỗ lực của người dân thị trấn để hỗ trợ và an ủi làn sóng khổng lồ của những người lạ bị sốc. Hàng loạt đề cử Emmy mà Lovecraft Country nhận được vào ngày 13 tháng 7 nhanh chóng trở thành một khoảnh khắc buồn vui lẫn lộn cho dàn diễn viên và những người sáng tạo ra loạt phim. Chỉ 11 ngày trước, HBO đã hủy bỏ bộ phim kinh dị siêu nhiên của Misha Green, người đã chuyển thể tiểu thuyết cùng tên của Matt Ruff lên màn ảnh nhỏ.
